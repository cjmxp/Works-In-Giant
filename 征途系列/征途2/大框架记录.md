[TOC]

额外插一句：在主项目中看这些分项目的代码，调试的时候不能断这些子项目（附加项目）的断点，所以稍微有些不方便。

## Client

## Client_compile
> 这个东西实际上不算一个独立的项目，跟Client是连在一起的一个筛选器，里面有不少的界面，配置也写在这个里面，这个部分应该是疏于管理，导致应该只是放联合编译UnityCompile的部分放入了Client的界面等其他文件。
1. 这个文件夹里面好像只是cpp文件的整合，放一起编译，可以看出哪些文件是一个时期写的。（不过也能通过提交记录查看）
2. 这个UnityCompile和联合编译器IncrediBuild没有直接的联系

## EncDec
> 这个主要是解码作用，包括了`md5`解码，压缩文件解压缩，主要应该是`md5`的解压。

## Engine
**注意，这个部分很大。这是整个征途引擎的骨架，接下来，一个文件夹（筛选器）一个文件夹的分析，拆解。**
### debug
1. 内含文件：`debug.cpp,debug.h,Log.cpp,StackWalker.cpp,StackWalker.h`
2. 这个模块主要是用来在dump的时候定位对应的堆栈，记录一些信息的。也就是大部分引擎都会有的`Log`模块类似的东西，不过多了一个`StackWalker`库。关于这个打印堆栈的模块，如果需要深入调查，还是查找相关的资料好。
3. 除此之外，`Log.cpp`的作用就是简单的在本地文件中，通过文件指针往文本文件里填写记录。
### Delegates
1. 内含文件：`Delegate.h,Event.h,EventArgs.h`
2. 这个委托和事件的移植，非常的给力，作者ouyangzhaofeng，后来去了腾讯的和平精英。里面的实现运用到了大量高级的C++14，C++11特性，大量的std算法，非常精简，当然由于抽象度高，代码理解起来也很吃力。
3. 运用到的特性大概有以下：万能引用，完美转发，智能指针，移动构造，模版可变参数，lambda，模版偏特化、全特化，std::find_if，std::for_each，std::enable_if，std::addressof,std::result_of_t,std::invoke,std::is_member_pointer,std::conditional_t,std::decay_t,std::remove_reference_t,std::is_same,std::add_pointer还有一大片。
### event
1. 内含文件：`EventBase.h,FastDelegate.h,FastDelegateBind.h,FastEvent.h,SafeEvent.h,SafeHook.cpp,SafeHook.h`
2. 这也是一个委托的实现，最早的版本，08年时取自口袋江湖项目组的代码，江湖的代码也是取自国外的库，跟上面的一比，就比较落后了（垃圾），且易用性也差了不少，随便举一个例子，模版的多参数问题，就远远比不上C++11的模版可变参数了。所以这部分现在已经被废弃了。比如有的还在用`stdext::hash_set`
### excel
1. 内含文件：`ExcelOperating.cpp,ExcelOperating.h`
2. 这是一个将统计数据生成到表格文件中去的一个代码，似乎应该归类到debug里面去，是小野后来加的。用到了自带的`ole2.h`库。
### graphic

### IO
### math
### memory
### net
### other
### register
### thread
### time
### utility
### YDY


## GGSafeLib
> 这个项目主要是加密，保密的内容，里面有一个`ZTGGSafe.h`巨盾的几个接口。其余是`md5,nn,prime,rsaref`等的密码性质的文件，不甚了解。
- 这个项目建议与EncDec项目一起连起来看。

## gui
### 这部分是游戏中所有控件的实现部分

1. 界面基础**GuiDialog**界面基类，**GuiControl**所有控件基类，**GuiManager**管理所有控件互动行为
2. 经常使用的`GuiButton`按钮，`GuiCheckBox`选择框，`GuiComboBox`，`GuiEditBox`输入框，`GuiImage`图片，`GuiMLTextBox`综合文字，`GuiRadioButton`圆钮，`GuiPanel`板子，`GuiSimpleTab`书签，**ToolTips**悬浮，`GuiTable`格子，`GuiStatic`文字，`GuiPar`粒子这些控件。
3. 比较少用到的`GuiMenu`菜单，`GuiProcess`进度条，`GuiTab`面板按钮，`AccelKey`快捷键，`GuiLine`，`GuiPallete`调色板，`GuiTree`树，任务的左边就是树。还有一些综合的小零件`GuiScrollBar`滚动条，`GuiSlider`刻度条，一般与其他的控件一起组合使用。
4. 几乎不使用或者已废弃的`gui_script`(完全没使用)，`GuiAutoPanel`废弃(被其他新panle控件替代),`GuiClipImage`没人用，`GuiClock`也没人用，`GuiCuttool`裁剪图片（只使用在相册有关界面），`GuiPoicListBox`也是相册集用，`GuiMovie`就看到过1次，`GuiSlideImage`没人用，`GuiTextImage`用图片的形式画文字
5.  `GuiEffectFactory`粒子和`CGuiEffectManager`粒子管理器。前者在需要设置好参数后再管理器中添加，不能在外单独创建粒子，粒子只能通过工厂产生。（不过后面多了一个GuiPar，估计这一套已经不用了）
6. 新写的部分（复合）：`GuiControlContainer`简单的控件容器，`GuiControlOwnershipContainer`带控制权的控件容器（继承前者）
7. `GuiElement`这个东西我一次没用过，但是看使用的场所很多，好像是纹理，绘图，放图的东西。可能是下一层的东西，很基础的`Render`相关的元素，且不继承`GuiControl`（的确是）
8. `GuiFloatItem`这个东西是道具的元素，继承的`GuiDialog`，里面创建是一个`GuiTable`，不是道具基类，比道具基类高一层，成员有`GuiItemCell`
9. `GuiItemCell`，道具格子的基类，成员里面也有`GuiTable`
10. `GuiSpine`骨骼动画，从征途3移植过来的，但是好像在征途2里面没有实际使用，由于移植时间是2019年，故不进入遗弃或不使用名单

### 还有Action部分
1. 
### 细节区别
- 里面有一个叫`GuiTab`和`GuiSimpleTab`的，前者几乎不用了，都在用后者了，据说是前者有性能问题，没仔细看。
- 里面还有一个叫`GuiControlContainer`和`GuiControlOwnershipContainer`的，后者从命名上比前者多了一个owner，这个就是说了一个所有权，内部实现差不多，后者继承的前者，多了一个`AddControl`的时候有一个`SetParent`操作，这样的话，后者在`SetVisible`的时候，会整体修改显示与否。
- 那个`GuiCuttool`还挺好玩的
- 奇怪，CGuiDialog的粒子工厂，每个窗口都只有一个，从`GetEffectFactory`的实现上来看是这样的。而且这个粒子效果好像只看到窗口的打开和关闭效果，其他的没看到


## ImGui
> 这是一个非常著名的gui库，[github仓库地址](https://github.com/ocornut/imgui/)。这个库怀疑是姬佬建议加进来的，应该是当初的QT和imgui二选一，可能imgui对于游戏更加的适合。拥有很强的自由，且创建很简单（immediate mode立即模式，绘图模式之一），可以用自己的渲染器渲染，但是本身是C++03写的，风格可能不是很习惯。而且unity使用的也是imgui。

1. 说一说立即模式和保存模式，传统的MVC模式写界面控件及响应事件，大概是：
```C++
// MVC传统模式
Edit a;

//另一处数据生命
string str_a;

//根据事件设置回调函数
a.set_call_back(msg_end_edit,a.on_edit);

//回调函数中传回数据
on_edit()
{
    str_a = a;
}

// 立即模式
string str_a;
inputtext(a);
```
立即模式主要是需要实时渲染，或者叫持续更新界面获取反馈。这种不需要保存在内存中 ，占用的内存资源较少，稍微多一点cpu占用，现在已经忽略不计了。主要是**实时**这特性跟游戏很贴切。

## liblua和liblualib
> 这两个也跟上面的差不多，是属于lua部分的基础部分。

## libprotoc和libprotobuf
> 这两个库都是跟proto有关的库，代码较多，且英文注释大片，不做过多的描述。protobuf是在proto基础上的。

## LuaBind
> 这个东西打交道很长时间了，从大学开始就研究C++转lua，lua转C++。
1. 这个项目里面有大量的`boost`相结合的内容，自然带有高质量开源库的特征`.hpp`包含大量模版。似乎和当初的边锋的lua转换代码不太一样。比如`boost::mpl`这个元编程库，是03年、04年完善的，边锋的应该不是这个方式。

2. 现在往回想，当初那个飞机的模拟物理引擎C++代码应该是不可能连C++整个特性一起拷过来。Lua中的基础类型`lua_State`是用来管理lua虚拟机的执行环境的类型，全局**唯一global_State**，其最主要的功能就是**C/C++的交互**以及函数调用。

## Magic
> 插一句，这些我记得我在免费版的时候，足迹，特效啥的梳理的比较清楚，来征途2之后有一点懈怠了。
### 大部分魔法
- 这个项目里面的内容大概包括了**地图，动画，粒子动画，动画组，地图摇晃震动，人物（动画动作部分），人物绘制和动作序列，灯光，灯光，魔法，粒子基类，粒子系统，粒子群，粒子管理器**，微端资源映射，**足迹管理器，魔法（特效）声音，地图添加模版，地图云雾管理器，地图场景，物体基类（很重要），装备部件绘制顺序，场景事物**,还有一个奇怪的`common`
1. 一些比较重要的基类，基础在这个项目里面，尽管我觉得他不应该在那。比如`Map`,`MapScene`,`c Chracter`,`ObjectBase`这些东西。
2. 这个项目实际上有部分跟渲染顺序，如人物的渲染顺序（身体，头盔，武器的顺序）；场景的物体基类，人物基类都在这。虽然这些基类也就非常很基础的东西。
3. 这个主角`Character`的成员有很多，`Light`就是其中之一。所以游戏里面带这个数据的，基本上都是跟cCharacter有关的，或者是继承的。
### 部分魔法实现
1. 晃动魔法：其中有一种是写死的，如晃动的间隔从stPointI(x,y)原位置开始往容器中依次放stPointI(x/2,y/2),stPointI(-x/3,-y/3)...到stPointI(x/32,y/32)的细小，然后在cMagicShake类里面的Run函数进行处理。
2. 这里面的魔法的引用计数，是自己写的部分，生成一个会在发生器上的m_count++。
### 游戏现象解释
1. 云雾是怎么回事：这不是简单的天气，真是可惜。是因为你是微端或者不完整客户端，这是用来遮掩的，也可能是内网服务器和客户端版本不一样，在`GameScene`中判断的`Run`函数调用了云雾管理器中的`Draw`，进行绘制。
2. 眼花的足迹是这里的，足迹管理器里面绘制的。但是我忘了免费版代码里在哪绘制的，也是对应的管理器吗？！我只记得这块免费版的魔盒，英语命名乱七八糟，抄来抄去。
3. 人物的绘制，持枪的动作，让我想起当初丰哥说的双人坐骑的一个绘制顺序的错误。不知道现在有没有修正了，不过是很底层的东西，估计也不好改。


## Media
> 这是一个解析媒体的一个项目，里面包含win32的自带媒体库（应该是，strmif.h文件,ddraw.h文件），但是这些个库我为什么搜不到相关的信息，好像也跟DX有关。

### 古老的音频相关代码
1. 包含的内容：`Movie，MoviePlayer播放器，MP3格式，Ogg格式阅读器，Scene场景音效，声音格式阅读器SoundBufferReader，SoundManager（这个为什么不放在Client项目里?是因为第三方吗，管理器不放一起吗？），VMR9 Video渲染（DX9实现的视频和图形呈现管道合并），Wav格式阅读器，Vorib编解码器，wxutil`

2. 这个项目，比较难看懂。多数是vs自带的库，或者第三方引用的相关文件。里面的宏定义`__IDvdGraphBuilder_FWD_DEFINED__`,`__IDrawVideoImage__FWD_DEFINED__`。

3. 这个声音的pos，为什么会有z坐标？这个读取Ogg格式的stream，已经很老的库了，里面的C还在用goto，97~01年的代码库。

4. 一共支持`mp3,ogg,wav`三种格式的音频文件。

5. 这个Media模块是在2018.12月加入的。**发现了，后面新加入的，但是属于旧的技术的模块，都是单独加出来在后面的**（好像也不对。。我不是很清楚这些实际加入时间）


## OleCtrl
> 这个项目的英文名称我都看不懂，里面的代码内容我也看不懂。
- 经过一番网上的查找，ole代表的是一种面向对象技术，利用这种技术可以开发可重复使用的软件组件。但是关于这一技术，是属于过去式了，微软已经宣布这一OLE已经不再代表对象链接与嵌入，仅仅是一个过去的名词。
- 这一套东西好像也没使用了。。。都没代码进入基类的构造函数
- 里面有`OleCtrls`为模式的控件，查找`Windows`句柄的窗口，`DxWebBrowser`这个好像最近雷神有用过，可能现在还在用。（最近修改防沉迷的时候有修改）
- 总结，现在就是一个浏览器。


## PinYin
> 这个模块就是简单的拼音搜索模块，属于第三方的库，看了一下实现逻辑，大概就是穷举法，列出来，带省略搜索功能，没有模糊搜索功能。
1. 这一点，我在当时搜索道具，增加无限仓库的搜索功能时发现，也就是宽字节问题，被问到`hp`搜索时如何跳出魂魄类道具，当时一时语塞，没想到并没有限制只能跳出魂魄，还可以有其他道具，所以可以全列出，尽量模糊搜索。具体的算法，其他的算法，推荐搜索，或者去详细的看。

2. 有一组拼音对应的map<string,int>，size是397组。。也就是说所有拼音组合一共是397组。主要是通过ASCII码来判断，即最小的字符串`a`和最大的字符串`zuo`的对应ASCII码是1601和5582。然后遍历这个转换的临时的`char*`指针，从大到小去接近这个ASCII码值。

3. 这个模糊（打错）的查找方式是查找5582以上的ASCII码值的，手写模糊。。妈的，写了一堆，这个算法找的可以。。是看上了这个代码行数了吧。。

## Property
> 这个项目是跟属性相关的内容，就是从excel表，本地文件等的读取的一些设置，比较的明确，且文件内容不多。感觉也有些老旧，可能底层的感觉就是这样的，我好久没回顾底层的一些东西了。

### lua_State
主要功能包括：

1. **数据栈管理，包括交互过程中参数压栈和出栈、函数注册的临时数据存储等。**

2. **调用栈管理，其中CallInfo结构表示一次调用，包括指向数据栈中数据边界指针top和base、被调用函数指针func。**

3. 全局表l_gt管理，注意：它其实只是在当前lua_State范围内是全局唯一的，和global_State的l_registry注册表不同，l_registry是lua虚拟机范围内是全局唯一的。

4. gc的一些管理和当前栈中upvalue的管理（出现闭包应用场景时）。

5. hook相关的，包括hookmask，hookcount，hook函数等（暂未了解）。

### 注册函数和操作原理
```C++
// Lua现在支持的库有：协程库、表操作库、io库、系统库、string库、math库、debug库、包处理库，以string库为例：

static const luaL_Reg strlib[] =
{

  {"byte", str_byte},

  {"char", str_char},

  {"dump", str_dump},

  {"find", str_find},

  {"format", str_format},

  {"gmatch", gmatch},

  {"gsub", str_gsub},

  {"len", str_len},

  {"lower", str_lower},

  {"match", str_match},

  {"rep", str_rep},

  {"reverse", str_reverse},

  {"sub", str_sub},

  {"upper", str_upper},

  {"pack", str_pack},

  {"packsize", str_packsize},

  {"unpack", str_unpack},

  {NULL, NULL}

};
luaL_register(L, LUA_STRLIBNAME, strlib); //注册函数
```
1. 函数的调用过程主要涉及2个虚拟栈，数据栈和调用栈，实质就是在调用过程中，一些指向栈的指针不断更新过程。具体的流程不在这里列出。可以去参考[博客](https://blog.csdn.net/wu554513392/article/details/60594724)

## Rana和RanaSrv
> 这是2个库项目，实际上与lua有关，不知为啥要叫Rana，而且这个项目时间很早，13年创立的lua编辑器，应该不是Decode，但看现在多使用Decode，所以这个编辑器应该没有启用。
1. Rana项目里面主要是`trigger`和消息传递相关的文件。
2. 里面有一些lua用的协议，不是很懂。
3. 这两个项目里面的内容不做过多的解读。

## RenderD3D8
**注意，这个部分很大**
> 这个就是Director3DX8了。


## SpineDx
> 这是一个骨骼动画相关的项目，包含动画，绑定啥的，这个研究起来应该还是挺快的。
1. 断点都没走进去。。这个是不是还没有使用案例
2. 基本上就是读取文件，构建，蒙皮，绑定等流程

## tinyhttp
> 这个库引入的是curl，高移植性的，基于C的多协议URL传输库；
1. 这个库里面用到的curl库应该是1月才从免费版拿过来用的，tinyhttp后面才使用。
2. curl的使用流程还是容易明了的，从博客上摘抄

### libcurl使用步骤
1. 调用curl_global_init()初始化libcurl
2. 调用curl_easy_init()函数得到 easy interface型指针
3. 调用curl_easy_setopt()设置传输选项
4. 根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务
5. 调用curl_easy_perform()函数完成传输任务
6. 调用curl_easy_cleanup()释放内存

## tinyinflux

## xml_parse

## zlib

## Zoic