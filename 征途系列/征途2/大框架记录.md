[TOC]

额外插一句：在主项目中看这些分项目的代码，调试的时候不能断这些子项目（附加项目）的断点，所以稍微有些不方便。

## Client

## Client_compile
> 这个东西实际上不算一个独立的项目，跟Client是连在一起的一个筛选器，里面有不少的界面，配置也写在这个里面，这个部分应该是疏于管理，导致应该只是放联合编译UnityCompile的部分放入了Client的界面等其他文件。
1. 这个文件夹里面好像只是cpp文件的整合，放一起编译，可以看出哪些文件是一个时期写的。（不过也能通过提交记录查看）
2. 这个UnityCompile和联合编译器IncrediBuild没有直接的联系

## EncDec
> 这个主要是解码作用，包括了`md5`解码，压缩文件解压缩，主要应该是`md5`的解压。

## Engine
**注意，这个部分很大。这是整个征途引擎的骨架，接下来，一个文件夹（筛选器）一个文件夹的分析，拆解。**
### debug
1. 内含文件：`debug.cpp,debug.h,Log.cpp,StackWalker.cpp,StackWalker.h`
2. 这个模块主要是用来在dump的时候定位对应的堆栈，记录一些信息的。也就是大部分引擎都会有的`Log`模块类似的东西，不过多了一个`StackWalker`库。关于这个打印堆栈的模块，如果需要深入调查，还是查找相关的资料好。
3. 除此之外，`Log.cpp`的作用就是简单的在本地文件中，通过文件指针往文本文件里填写记录。
### Delegates
1. 内含文件：`Delegate.h,Event.h,EventArgs.h`
2. 这个委托和事件的移植，非常的给力，作者ouyangzhaofeng，后来去了腾讯的和平精英。里面的实现运用到了大量高级的C++14，C++11特性，大量的std算法，非常精简，当然由于抽象度高，代码理解起来也很吃力。
3. 运用到的特性大概有以下：万能引用，完美转发，智能指针，移动构造，模版可变参数，lambda，模版偏特化、全特化，std::find_if，std::for_each，std::enable_if，std::addressof,std::result_of_t,std::invoke,std::is_member_pointer,std::conditional_t,std::decay_t,std::remove_reference_t,std::is_same,std::add_pointer还有一大片。
### event
1. 内含文件：`EventBase.h,FastDelegate.h,FastDelegateBind.h,FastEvent.h,SafeEvent.h,SafeHook.cpp,SafeHook.h`
2. 这也是一个委托的实现，最早的版本，08年时取自口袋江湖项目组的代码，江湖的代码也是取自国外的库，跟上面的一比，就比较落后了（垃圾），且易用性也差了不少，随便举一个例子，模版的多参数问题，就远远比不上C++11的模版可变参数了。所以这部分现在已经被废弃了。比如有的还在用`stdext::hash_set`
### excel
1. 内含文件：`ExcelOperating.cpp,ExcelOperating.h`
2. 这是一个将统计数据生成到表格文件中去的一个代码，似乎应该归类到debug里面去，是小野后来加的。用到了自带的`ole2.h`库。
### graphic

### IO
### math
### memory
### net
### other
### register
### thread
### time
### utility
### YDY


## GGSafeLib
> 这个项目主要是加密，保密的内容，里面有一个`ZTGGSafe.h`巨盾的几个接口。其余是`md5,nn,prime,rsaref`等的密码性质的文件，不甚了解。
- 这个项目建议与EncDec项目一起连起来看。

## gui


## ImGui
> 这是一个非常著名的gui库，[github仓库地址](https://github.com/ocornut/imgui/)。这个库怀疑是姬佬建议加进来的，应该是当初的QT和imgui二选一，可能imgui对于游戏更加的适合。拥有很强的自由，且创建很简单（immediate mode立即模式，绘图模式之一），可以用自己的渲染器渲染，但是本身是C++03写的，风格可能不是很习惯。而且unity使用的也是imgui。

1. 说一说立即模式和保存模式，传统的MVC模式写界面控件及响应事件，大概是：
```C++
// MVC传统模式
Edit a;

//另一处数据生命
string str_a;

//根据事件设置回调函数
a.set_call_back(msg_end_edit,a.on_edit);

//回调函数中传回数据
on_edit()
{
    str_a = a;
}

// 立即模式
string str_a;
inputtext(a);
```
立即模式主要是需要实时渲染，或者叫持续更新界面获取反馈。这种不需要保存在内存中 ，占用的内存资源较少，稍微多一点cpu占用，现在已经忽略不计了。主要是**实时**这特性跟游戏很贴切。

## liblua和liblualib
> 这两个也跟上面的差不多，是属于lua部分的基础部分。

## libprotoc和libprotobuf
> 这两个库都是跟proto有关的库，代码较多，且英文注释大片，不做过多的描述。protobuf是在proto基础上的。

## LuaBind
> 这个东西打交道很长时间了，从大学开始就研究C++转lua，lua转C++。
1. 这个项目里面有大量的`boost`相结合的内容，自然带有高质量开源库的特征`.hpp`包含大量模版。似乎和当初的边锋的lua转换代码不太一样。比如`boost::mpl`这个元编程库，是03年、04年完善的，边锋的应该不是这个方式。

2. 现在往回想，当初那个飞机的模拟物理引擎C++代码应该是不可能连C++整个特性一起拷过来。Lua中的基础类型`lua_State`是用来管理lua虚拟机的执行环境的类型，全局**唯一global_State**，其最主要的功能就是**C/C++的交互**以及函数调用。

## Magic
> 这部分的总结，应该在surface 上，没有push上来

## Media
> 这是一个解析媒体的一个项目，里面包含win32的自带媒体库（应该是，strmif.h文件,ddraw.h文件），但是这些个库我为什么搜不到相关的信息，好像也跟DX有关。

### 古老的音频相关代码
1. 包含的内容：`Movie，MoviePlayer播放器，MP3格式，Ogg格式阅读器，Scene场景音效，声音格式阅读器SoundBufferReader，SoundManager（这个为什么不放在Client项目里?是因为第三方吗，管理器不放一起吗？），VMR9 Video渲染（DX9实现的视频和图形呈现管道合并），Wav格式阅读器，Vorib编解码器，wxutil`

2. 这个项目，比较难看懂。多数是vs自带的库，或者第三方引用的相关文件。里面的宏定义`__IDvdGraphBuilder_FWD_DEFINED__`,`__IDrawVideoImage__FWD_DEFINED__`。

3. 这个声音的pos，为什么会有z坐标？这个读取Ogg格式的stream，已经很老的库了，里面的C还在用goto，97~01年的代码库。

4. 一共支持`mp3,ogg,wav`三种格式的音频文件。

5. 这个Media模块是在2018.12月加入的。**发现了，后面新加入的，但是属于旧的技术的模块，都是单独加出来在后面的**（好像也不对。。我不是很清楚这些实际加入时间）


## OleCtrl
> 这个项目的英文名称我都看不懂，里面的代码内容我也看不懂。
- 经过一番网上的查找，ole代表的是一种面向对象技术，利用这种技术可以开发可重复使用的软件组件。但是关于这一技术，是属于过去式了，微软已经宣布这一OLE已经不再代表对象链接与嵌入，仅仅是一个过去的名词。
- 这一套东西好像也没使用了。。。都没代码进入基类的构造函数
- 里面有`OleCtrls`为模式的控件，查找`Windows`句柄的窗口，`DxWebBrowser`这个好像最近雷神有用过，可能现在还在用。（最近修改防沉迷的时候有修改）
- 总结，现在就是一个浏览器。


## PinYin
> 这个模块就是简单的拼音搜索模块，属于第三方的库，看了一下实现逻辑，大概就是穷举法，列出来，带省略搜索功能，没有模糊搜索功能。
1. 这一点，我在当时搜索道具，增加无限仓库的搜索功能时发现，也就是宽字节问题，被问到`hp`搜索时如何跳出魂魄类道具，当时一时语塞，没想到并没有限制只能跳出魂魄，还可以有其他道具，所以可以全列出，尽量模糊搜索。具体的算法，其他的算法，推荐搜索，或者去详细的看。

2. 有一组拼音对应的map<string,int>，size是397组。。也就是说所有拼音组合一共是397组。主要是通过ASCII码来判断，即最小的字符串`a`和最大的字符串`zuo`的对应ASCII码是1601和5582。然后遍历这个转换的临时的`char*`指针，从大到小去接近这个ASCII码值。

3. 这个模糊（打错）的查找方式是查找5582以上的ASCII码值的，手写模糊。。妈的，写了一堆，这个算法找的可以。。是看上了这个代码行数了吧。。

## Property
> 这个项目是跟属性相关的内容，就是从excel表，本地文件等的读取的一些设置，比较的明确，且文件内容不多。感觉也有些老旧，可能底层的感觉就是这样的，我好久没回顾底层的一些东西了。

### lua_State
主要功能包括：

1. **数据栈管理，包括交互过程中参数压栈和出栈、函数注册的临时数据存储等。**

2. **调用栈管理，其中CallInfo结构表示一次调用，包括指向数据栈中数据边界指针top和base、被调用函数指针func。**

3. 全局表l_gt管理，注意：它其实只是在当前lua_State范围内是全局唯一的，和global_State的l_registry注册表不同，l_registry是lua虚拟机范围内是全局唯一的。

4. gc的一些管理和当前栈中upvalue的管理（出现闭包应用场景时）。

5. hook相关的，包括hookmask，hookcount，hook函数等（暂未了解）。

### 注册函数和操作原理
```C++
// Lua现在支持的库有：协程库、表操作库、io库、系统库、string库、math库、debug库、包处理库，以string库为例：

static const luaL_Reg strlib[] =
{

  {"byte", str_byte},

  {"char", str_char},

  {"dump", str_dump},

  {"find", str_find},

  {"format", str_format},

  {"gmatch", gmatch},

  {"gsub", str_gsub},

  {"len", str_len},

  {"lower", str_lower},

  {"match", str_match},

  {"rep", str_rep},

  {"reverse", str_reverse},

  {"sub", str_sub},

  {"upper", str_upper},

  {"pack", str_pack},

  {"packsize", str_packsize},

  {"unpack", str_unpack},

  {NULL, NULL}

};
luaL_register(L, LUA_STRLIBNAME, strlib); //注册函数
```
1. 函数的调用过程主要涉及2个虚拟栈，数据栈和调用栈，实质就是在调用过程中，一些指向栈的指针不断更新过程。具体的流程不在这里列出。可以去参考[博客](https://blog.csdn.net/wu554513392/article/details/60594724)

## Rana和RanaSrv
> 这是2个库项目，实际上与lua有关，不知为啥要叫Rana，而且这个项目时间很早，13年创立的lua编辑器，应该不是Decode，但看现在多使用Decode，所以这个编辑器应该没有启用。
1. Rana项目里面主要是`trigger`和消息传递相关的文件。
2. 里面有一些lua用的协议，不是很懂。
3. 这两个项目里面的内容不做过多的解读。

## RenderD3D8
**注意，这个部分很大**
> 这个就是Director3DX8了。


## SpineDx
> 这是一个骨骼动画相关的项目，包含动画，绑定啥的，这个研究起来应该还是挺快的。
1. 断点都没走进去。。这个是不是还没有使用案例
2. 基本上就是读取文件，构建，蒙皮，绑定等流程

## tinyhttp
> 这个库引入的是curl，高移植性的，基于C的多协议URL传输库；
1. 这个库里面用到的curl库应该是1月才从免费版拿过来用的，tinyhttp后面才使用。
2. curl的使用流程还是容易明了的，从博客上摘抄

### libcurl使用步骤
1. 调用curl_global_init()初始化libcurl
2. 调用curl_easy_init()函数得到 easy interface型指针
3. 调用curl_easy_setopt()设置传输选项
4. 根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务
5. 调用curl_easy_perform()函数完成传输任务
6. 调用curl_easy_cleanup()释放内存

## tinyinflux

## xml_parse

## zlib

## Zoic