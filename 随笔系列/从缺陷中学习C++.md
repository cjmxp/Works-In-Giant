[TOC]
# 从缺陷中学习C/C++
> 这本书毛看看像是一本记录很实际，直接工作上遇到的问题，是QA结合程序总结而成。

1. 提到了一个点，类的拷贝构造中的`operator =`赋值构造，返回的必须是引用，如果是值，会有无限调用拷贝构造，造成死循环。这里面牵涉出一个函数返回值和引用的区别。返回值，会有一个匿名变量作为过渡。
2. 拷贝构造函数不能模板化（5.3节）
3. 析构函数不能抛出异常。（书中举的例子是连续抛出异常，需要知道如果异常没有被捕获到，就会层层向上到std::terminate，所以这会对try-catch造成影响，也会对一般的异常依次栈展开析构数据时造成影响，会宕机）
4. 构造函数不建议抛出异常，但是不绝对，只要你抛出的时候记得如果有申请空间，把空间free掉。
5. C++标准中明确说明，针对*Void指针做delete会引发未定义行为。
6. std里面的容器，如果存放的是指针，`::clear`函数无法将这些指针进行处理，释放。但是如果是对象，就能解析时自动释放。std容器的push是根据复制拷贝存入的，但是有emplace，有了移动之后效率大幅提升了，自C++11开始启用。
7. static变量在类里面只有整型性质的变量可以初始化，其他都在外面。
8. union是一个比较特殊的数据类型，成员公用一片内存，大小是他最大的一个成员类型的大小，比较麻烦，估计只有在面试的时候会遇到。
9. const 类对象只能使用const函数，所以好的编程习惯是将不会修改成员变量的函数置为const。
10. memset会把带虚函数指针和虚函数表的类空间清空。
11. dynamic_cast只能在子转父可以转，当然必须要有虚函数，切可能转换失败。
12. **指针的指针和指针的引用问题，只用理解了，如果函数这样声明`int func(int *Pres)`，这样的话这个函数依旧是使用的值传递，如果`int *pres = NULL`,然后func(pres)这样调用，依旧不会改变**，再仔细想想，这个是对的，也相对的解释了当初二叉树的问题。
13. 跟12的关键点一起看，重新来明确指针的四要素，传入的指针相当于复制了一把指针，但是指针指明的地址的里面那个数字是可以改变的，会引起外面的数值的改变。**这一点非常的关键，用钥匙和房子来理解非常容易**，这也是用指针传递地址，然后修改结构体里面的参数的核心原因。
14. 临时变量的问题，有一个提到了你这个变量是在栈上还是堆上，在堆上可以返回不会被释放，如果是在栈上，函数返回时会自动收回，堆上的需要new等。
15. 第14条的说明也对一般的变量起作用，当你返回某个引用的时候，也要注意是否会回收，因为一般的值变量，也是建立在栈上的。
16. 对容器的大小和判空的使用，跟性能相关。如`strlen`的使用，基本上是消耗中性能的，不能频繁调用，用临时变量过渡。再如`xx.size()`对不同的容器，不同的编译器，不同的系统有不同的实现，list的size可能是O(1)也可能是O(n)。而`xx.empty()`一直是O(1)。而且vector的本身所占大小，不会因为`clear`而释放，不过可以与空的一个临时vector进行swap，不过这种应该应用比较少。
# 已阅